---
source: ch6/src/pass/array_bounds.rs
expression: result.to_string_pretty()
---
(let
 [x
  (let
   [(bounds-tmp-index) 3]
   (if
    (>= (bounds-tmp-index) 0)
    (make-vector
     (bounds-tmp-index)
     #t)
    (length-error
     (bounds-tmp-index))))]
 (let
  [i 1]
  (let
   [y
    (let
     [(bounds-tmp-vec) x]
     (let
      [(bounds-tmp-index) i]
      (if
       (and
        (>=
         (bounds-tmp-index)
         0)
        (<
         (bounds-tmp-index)
         (vector-length
          (bounds-tmp-vec))))
       (vector-ref
        (bounds-tmp-vec)
        (bounds-tmp-index))
       (out-of-bounds-error
        (bounds-tmp-index)
        (vector-length
         (bounds-tmp-vec))))))]
   (let
    [z (vector 1 #t "abc")]
    (begin
    (let
      [(bounds-tmp-vec) x]
      (let
       [(bounds-tmp-index) i]
       (if
        (and
         (>=
          (bounds-tmp-index)
          0)
         (<
          (bounds-tmp-index)
          (vector-length
           (bounds-tmp-vec))))
        (vector-set!
         (bounds-tmp-vec)
         (bounds-tmp-index)
         (vector-ref z 1))
        (out-of-bounds-error
         (bounds-tmp-index)
         (vector-length
          (bounds-tmp-vec))))))
     (vector-set!
      z
      1
      (not y)))))))
